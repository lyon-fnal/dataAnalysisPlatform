---
title: "Escaped Muons"
date: 2017-03-21
author: Adam Lyon
output: 
  html_notebook: 
    number_sections: yes
    toc: yes
---
# Introduction 

The goal of this document is to examine "escaped muons" that do not decay in the storage region and do not enter a calorimeter. Some of these muons may leave the storage ring altogether. 

I generated art files of simulated events using `mdc2` with different magnetic fields turned on or off (scenarios). 
We want to examine,

* Muons that are eaten by the iron yoke and muons that escape the world volume entirely. 
* Where do muons escape the world (3D and heat map plots?)
* Comparison of the different scenarios


```{r message=FALSE, warning=FALSE}
# Load necessary libraries
library(stringr)   # string functions
library(parallel)  # Parallel processing (built-in to R)
library(dplyr)     # data analysis
library(purrr)     # Functional programming
library(readr)     # Read formats
library(ggplot2)   # ploting
library(rgl)       # 3D plots
library(gridExtra) # Arranging plots
library(testthat)  # testing
#
library(readGallery) # Read art Gallery files
```

```{r}
# Put all readGallery::useDataProduct calls here
useDataProduct('std::vector<gm2truth::TrackingActionArtRecord>')
```


# Load the samples

Samples are located on the Fermilab dCache in the directory `/pnfs/GM2/scratch/users/lyon/arr_20170321`. 

```{r}
# Function to properly alter paths to accomodate XRootD
#    e.g. convert /pnfs/BLA --> root://fndca1.fnal.gov/pnfs/fnal.gov/usr/BLA
xrootd_ify <- function(aPath) paste0('root://fndca1.fnal.gov/pnfs/fnal.gov/usr', str_replace(aPath, '/pnfs', ''))
```

Determine the locations of the data files
```{r}
# Determine locations of our files
system("ssh lyon@gm2gpvm04.fnal.gov 'ls /pnfs/GM2/scratch/users/lyon/arr_20170321/*/*.root'", intern=T) -> arrFiles
arrFiles %>% xrootd_ify() -> arrXrdFiles
arrXrdFiles
```
Pull out the scenaios (these will be in the same order as the file names)
```{r}
scenarios <- str_match(arrFiles, 'arr_20170321/.+unified_(.+)_cyl')[,2]
scenarios %>% unique()
```

Let's look at the contents of these files (they're all the same, so we'll just do one) `gm2 v7_04_00` will have `product_sizes_dumper`. 
```{r}
stringToRun <- str_interp(
  "ssh lyon@gm2gpvm04.fnal.gov 'source /cvmfs/gm2.opensciencegrid.org/prod7/g-2/setup
   setup gm2 v7_04_00 -q prof ; 
   product_sizes_dumper ${aFile} | grep ::'", 
  list(aFile = arrFiles[1])
)
#
system(stringToRun)
```
# Escaping muons from the Tracking Action data

The tracking action data has birth and death data for every Geant track. 

## Load Tracking Action data 

We'll capture this information for the primary muon and its first generation daughters. See [gm2dataproducts/mc/actions/track/TrackingActionArtRecord.hh](https://redmine.fnal.gov/redmine/projects/gm2dataproducts/repository/entry/mc/actions/track/TrackingActionArtRecord.hh?rev=feature%2Fmdc2). 

We need a `readGallery` reader python class. Generate with,
```r
readerClassSkel('gm2truth::TrackingActionArtRecord', writeFile = 'trackingActionReader.py')
```

Here is the reader,
```{r}
read_file('trackingActionReader.py') %>% cat
```

Make the reader class and object
```{r}
trackingActionReaderC <- createReaderClass_from_file('trackingActionReader.py')$TrackingActionArtRecordReader
```
We have many files to process. Let's do this reading in `parallel`. 

We need to create a reader object per parallel job
```{r}
trackingActionReaders <- map(1:length(arrXrdFiles), function(i) trackingActionReaderC(artInputTag("artg4")))
```

Load the data
```{r}
jobs <- lapply(1:length(arrXrdFiles), function(i) getGalleryData(arrXrdFiles[i], trackingActionReaders[[i]]) %>%
                                                    mcparallel(name=i))
trackingActionReturns <- mccollect(jobs)
```

Let's merge all of the output.

```{r}
trackingActionDF <- map_df(1:length(trackingActionReaders), 
                           function(i) galleryReader_df(trackingActionReaders[[i]]) %>% mutate(scenario=scenarios[i], 
                                                                                               fileEntry=i))
trackingActionDF
```
```{r}
# Write this out so we don't need to do the above again
write_rds(trackingActionDF, 'trackingActionDF.rds')
```

How many muons per file?
```{r}
trackingActionDF %>% filter(trackID==1) %>% group_by(scenario, fileEntry) %>% tally()
```

### Add Volume Names

We need to turn the volume IDs into volume names. The volume IDs change for each file. We can run a small art job to determine the volume ID to name tables. 

```{r}
runForVolIDString <- function(i) {
  str_interp(
    "PVS_CSVOUT=${csvout}_${i}_volNames.csv gm2 -c ${fclPath}/gm2analyses/fcl/physicalVolumeStoreToFile.fcl -n 1 ${aFile}",
    list( csvout=scenarios[i], i=i, fclPath=Sys.getenv("MRB_BUILDDIR"), aFile=arrXrdFiles[i]) 
  )
}
runForVolIDStrings <- sapply(1:length(arrXrdFiles), runForVolIDString)
runForVolIDStrings
```
Let's run the art jobs in parallel

```{r}
jobs <- lapply(1:length(arrXrdFiles), function(i) mcparallel(system( runForVolIDStrings[i], intern=T ), name=i))
res <- mccollect(jobs)
```

and load the CSV files. 
```{r message=FALSE}
jobs <- lapply(1:length(arrFiles), function(i) 
  str_interp("${scn}_${i}_volNames.csv", list(scn=scenarios[i], i=i)) %>%
    read_csv(col_names=c("volumeUID", "volName")) %>% mcparallel(name=i) )
#
volNameTables <- mccollect(jobs)
volNameDF <- map_df(1:length(volNameTables), function(i) 
                      volNameTables[[i]] %>% mutate(scenario=scenarios[i],
                                                    fileEntry=i))
volNameDF
```
Now we merge with the tracking action data frame
```{r}
trackingActionDF %>% inner_join(volNameDF) %>% 
  select(scenario, fileEntry, eventEntry, volName, everything()) -> trackingActionNDF
trackingActionNDF
```

## How many muons decay in the storage region?

These muon decay in the storage region (not quite the same as "stored"),
```{r}
trackingActionNDF %>% filter(trackID==1, volName=='ArcSection[00]') %>% 
  group_by(scenario, fileEntry) %>% tally()
```
Interesting! So, from this, only `r 115/20000*100`% decay in the storage region for the "all on" (or everything) sample. That seems rather low. But continuing. 
```{r}
write_rds(trackingActionNDF, 'trackingActionNDF.rds')
```

## Where do muons go to die?

```{r}
trackingActionNDF %>% filter(trackID == 1) %>% group_by(scenario, volName) %>% tally()
```
It may be nice to categorize the volume names by area (e.g. "Arc", "bellows", "Ring", "Inflector").

```{r}
# Pull out the first word in camel case (see http://stackoverflow.com/questions/29916065/how-to-do-camelcase-split-in-python)
camelCaseSplit <- function(s) str_split(s, '(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])')
```

```{r}
# Test the above
expect_equal(camelCaseSplit("RingPoleTipUpper")[[1]], c("Ring", "Pole", "Tip", "Upper"))
expect_equal(camelCaseSplit("ringPoleTipUpper")[[1]], c("ring", "Pole", "Tip", "Upper"))
expect_equal(camelCaseSplit("world")[[1]], c("world"))
expect_equal(camelCaseSplit("ringPole")[[1]], c("ring", "Pole"))
```

```{r}
# We really just want the first word
takeFirstCamel <- function(s) camelCaseSplit(s) %>% map_chr(function(s) s[1])
takeFirstCamel("RingPoleTipUpper") %>% expect_equal("Ring")
takeFirstCamel("ringPoleTipUpper") %>% expect_equal("ring")
takeFirstCamel("world") %>% expect_equal("world")
takeFirstCamel("ringPole") %>% expect_equal("ring")
takeFirstCamel(c("ringPoleTipUpper", "world")) %>% expect_equal(c("ring", "world"))
```


```{r}
trackingActionNDF %>% mutate(volCategory = volName %>% takeFirstCamel) -> trackingActionNVDF
trackingActionNVDF
```
Show count by category
```{r}
trackingActionNVDF %>% filter(trackID ==1) %>% group_by(scenario, volCategory) %>% tally() -> volCatTally
volCatTally %>% mutate(perc = n/20000 * 100) -> volCatTally
volCatTally
```
Let's plot!
```{r}
trackingActionNVDF %>% filter(trackID ==1) %>% ggplot(aes(x=volCategory, group=scenario)) + 
  geom_bar()
```
```{r}
ggplot(volCatTally, aes(x = volCategory, y=perc, fill=scenario)) + 
  geom_bar(stat="Identity", width=0.5, position="dodge")
```
Can't really see non-Ring/world ones.  Let's split them out.

```{r}
# Function to make this easy
plotit <- function(d) ggplot(d, aes(x = volCategory, y=perc, fill=scenario) ) + 
  geom_bar(stat="Identity", width=0.5, position="dodge") + 
  xlab("Volume category") + ylab("Percent")

volCatTally %>% filter(volCategory %in% c("Ring", "world")) %>% plotit -> p1

volCatTally %>% filter(! volCategory %in% c("Ring", "world")) %>% plotit -> p2

grid.arrange(p1, p2)
```
Let's see where they die
```{r}
plotCommon <- function(p) p + 
               facet_wrap(~scenario) + 
               guides(col = guide_legend(override.aes = list(size=5, alpha=1))) +
               scale_color_discrete(name="Volume\nCategory") + 
               labs(x="z (mm)", y="x (mm)") +
               theme_minimal()
```


```{r fig.height=8}
trackingActionNVDF %>% filter(trackID == 1) %>% 
  ggplot( aes(x=z, y=x, color=volCategory)) + 
    geom_point(alpha=0.1) + 
    ggtitle('Where Muons Die') +
    facet_wrap(~scenario) + 
    guides(col = guide_legend(override.aes = list(size=5, alpha=1))) +
    scale_color_discrete(name="Volume\nCategory") + 
    labs(x="z (mm)", y="x (mm)") +
    theme_minimal()
```
Here it is without the ring losses, which dominate
```{r fig.height=8}
trackingActionNVDF %>% filter(trackID == 1, volCategory != 'Ring') %>% 
  ggplot( aes(x=z, y=x, color=volCategory)) + 
    geom_point(alpha=0.5) + 
    facet_wrap(~scenario) + 
    guides(col = guide_legend(override.aes = list(size=5, alpha=1))) +
    ggtitle("Where Muons Die", subtitle = "Ring escapees excluded for clarity") +
    scale_color_discrete(name="Volume\nCategory") + 
    labs(x="z (mm)", y="x (mm)") +
    theme_minimal()
```
