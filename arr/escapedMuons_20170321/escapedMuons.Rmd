---
title: "Escaped Muons"
date: 2017-03-21
author: Adam Lyon
output: 
  html_notebook: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: inline
---
**Plot list** (for 3D plots scroll down from the legend; you can rotate and zoom the 3D plots with your mouse):<br/>
<a href="#volCategoryPlots">Volume Category Histograms</a> |
<a href="#coffeering">Where muons die (coffee ring plots)</a> |
<a href="#muoniniron">Muon ranging out in iron yoke</a> |
<a href="#muonScatInfl">Muon scatters in inflector</a> |
<a href="#histdistring">Distance distribution in Ring iron</a> |
<a href="#energyloss">Energy loss in volumes</a> |
<a href="#nsteps">Number of steps in volumes</a> |
<a href="#muonIronLong">Another muon in the iron</a> |
<a href="#longMuon">Stored muon</a> |
<a href="#cbo">Coherent Betatron Oscillation</a>

# Introduction 

The goal of this document is to examine "escaped muons" that do not decay in the storage region and do not enter a calorimeter. Some of these muons may leave the storage ring altogether. 

I generated art files of simulated events using `mdc2` with different magnetic fields turned on or off (scenarios). **Note:** These files are still not the latest version of MDC2. Nathan is tuning up the injection gun. So right now the storage efficiency I see (0.5%) is still low. Should get better with the next round.
We want to examine,

* Muons that are eaten by the iron yoke and muons that escape the world volume entirely. 
* Where do muons escape the world (3D and heat map plots?)
* Comparison of the different scenarios


```{r message=FALSE, warning=FALSE}
# Load necessary libraries
library(reticulate)  # Access to python
library(stringr)   # string functions
library(parallel)  # Parallel processing (built-in to R)
library(dplyr)     # data analysis
library(purrr)     # Functional programming
library(readr)     # Read formats
library(ggplot2)   # ploting
library(rgl)       # 3D plots
library(gridExtra) # Arranging plots
library(testthat)  # testing
#
library(readGallery) # Read art Gallery files
```

```{r}
# Put all readGallery::useDataProduct calls here
useDataProduct('std::vector<gm2truth::TrackingActionArtRecord>')
useDataProduct('std::vector<gm2ringsim::GeantTrackRecord>')
useDataProduct('std::vector<gm2truth::GhostDetectorArtRecord>')
```

```{r}
# To restore most of the environment
trackingActionDF <- read_rds('trackingActionDF.rds')
trackingActionNDF <- read_rds('trackingActionNDF.rds')
volNameDF <- read_rds('volNameDF.rds')
ghCylDF <- read_rds('ghCylDF.rds')
ghWldDF <- read_rds('ghWldDF.rds')
```

# Load the samples

Samples are located on the Fermilab dCache in the directory `/pnfs/GM2/scratch/users/lyon/arr_20170321`. 

```{r}
# Function to properly alter paths to accomodate XRootD
#    e.g. convert /pnfs/BLA --> root://fndca1.fnal.gov/pnfs/fnal.gov/usr/BLA
xrootd_ify <- function(aPath) paste0('root://fndca1.fnal.gov/pnfs/fnal.gov/usr', str_replace(aPath, '/pnfs', ''))
```

Determine the locations of the data files
```{r}
# Determine locations of our files
system("ifdh ls '/pnfs/GM2/scratch/users/lyon/arr_20170321/*/*.root' | grep ARR", intern=T) %>% sort() -> arrFiles
```
```{r}
arrFiles %>% xrootify() -> arrXrdFiles
arrXrdFiles
```
```{r}
write_rds(arrFiles, 'arrFiles.rds')
```

Pull out the scenaios (these will be in the same order as the file names)
```{r}
scenarios <- str_match(arrFiles, 'arr_20170321/.+unified_(.+)_cyl')[,2]
scenarios %>% unique()
```

Let's look at the contents of these files (they're all the same, so we'll just do one) `gm2 v7_04_00` will have `product_sizes_dumper`. 
```{r}
stringToRun <- str_interp(
  "ssh lyon@gm2gpvm04.fnal.gov 'source /cvmfs/gm2.opensciencegrid.org/prod7/g-2/setup
   setup gm2 v7_04_00 -q prof ; 
   product_sizes_dumper ${aFile} | grep ::'", 
  list(aFile = arrFiles[1] %>% str_replace('fnal.gov/usr/',''))
)
#
system(stringToRun)
```
# Escaping muons from the Tracking Action data

The tracking action data has birth and death data for every Geant track. 

## Load Tracking Action data 

We'll capture this information for the primary muon and its first generation daughters. See [gm2dataproducts/mc/actions/track/TrackingActionArtRecord.hh](https://redmine.fnal.gov/redmine/projects/gm2dataproducts/repository/entry/mc/actions/track/TrackingActionArtRecord.hh?rev=feature%2Fmdc2). 

We need a `readGallery` reader python class. Generate with,
```r
readerClassSkel('gm2truth::TrackingActionArtRecord', writeFile = 'trackingActionReader.py')
```

Here is the reader,
```{r}
read_file('trackingActionReader.py') %>% cat
```

Make the reader class and object
```{r}
trackingActionReaderC <- createReaderClass_from_file('trackingActionReader.py')$TrackingActionArtRecordReader
```
We have many files to process. Let's do this reading in `parallel`. 

We need to create a reader object per parallel job
```{r}
trackingActionReaders <- map(1:length(arrXrdFiles), function(i) trackingActionReaderC(artInputTag("artg4")))
```

Load the data
```{r}
# For some reason these jobs seem to run serially
jobs <- lapply(1:length(arrXrdFiles), function(i) getGalleryData(arrXrdFiles[i], trackingActionReaders[[i]]) %>%
                                                    mcparallel(name=i))
trackingActionReturns <- mccollect(jobs)
```

Let's merge all of the output.

```{r}
trackingActionDF <- map_df(1:length(trackingActionReaders), 
                           function(i) galleryReader_df(trackingActionReaders[[i]]) %>% 
                             mutate(scenario=scenarios[i],fileEntry=i))
```
```{r}
nrow(trackingActionDF)
trackingActionDF %>% head(100)  # Let's not dump the entire data frame into the HTML page
```
```{r}
# Write this out so we don't need to do the above again
write_rds(trackingActionDF, 'trackingActionDF.rds')
```

How many muons per file?
```{r}
trackingActionDF %>% filter(trackID==1) %>% group_by(scenario, fileEntry) %>% tally()
```

### Add Volume Names

We need to turn the volume IDs into volume names. The volume IDs change for each file. We can run a small art job to determine the volume ID to name tables. 

```{r}
runForVolIDString <- function(i) {
  str_interp(
    "PVS_CSVOUT=${csvout}_${i}_volNames.csv gm2 -c ${fclPath}/gm2analyses/fcl/physicalVolumeStoreToFile.fcl -n 1 ${aFile}",
    list( csvout=scenarios[i], i=i, fclPath=Sys.getenv("MRB_BUILDDIR"), aFile=arrXrdFiles[i]) 
  )
}
runForVolIDStrings <- sapply(1:length(arrXrdFiles), runForVolIDString)
runForVolIDStrings
```
Let's run the art jobs in parallel

```{r}
jobs <- lapply(1:length(arrXrdFiles), function(i) mcparallel(system( runForVolIDStrings[i], intern=T ), name=i))
res <- mccollect(jobs)
```

and load the CSV files. 
```{r message=FALSE}
jobs <- lapply(1:length(arrFiles), function(i) 
  str_interp("${scn}_${i}_volNames.csv", list(scn=scenarios[i], i=i)) %>%
    read_csv(col_names=c("volumeUID", "volName")) %>% mcparallel(name=i) )
#
volNameTables <- mccollect(jobs)
volNameDF <- map_df(1:length(volNameTables), function(i) 
                      volNameTables[[i]] %>% mutate(scenario=scenarios[i],
                                                    fileEntry=i))
nrow(volNameDF)
volNameDF %>% head(100)
```
```{r}
write_rds(volNameDF, 'volNameDF.rds')
```

Now we merge with the tracking action data frame
```{r}
trackingActionDF %>% inner_join(volNameDF) %>% 
  select(scenario, fileEntry, eventEntry, volName, everything()) -> trackingActionNDF
nrow(trackingActionNDF)
trackingActionNDF %>% head(100)
```

## How many muons decay in the storage region?

These muons decay in the storage region (not quite the same as "stored"),
```{r}
trackingActionNDF %>% filter(trackID==1, volName=='ArcSection[00]') %>% 
  group_by(scenario, fileEntry) %>% tally()
```
Interesting! So, from this, only `r 115/20000*100`% decay in the storage region for the "all on" (or everything) sample. That seems rather low. But continuing. 
```{r}
write_rds(trackingActionNDF, 'trackingActionNDF.rds')
```

## Where do muons go to die?

```{r}
trackingActionNDF %>% filter(trackID == 1) %>% group_by(scenario, volName) %>% tally()
```
It may be nice to categorize the volume names by area (e.g. "Arc", "bellows", "Ring", "Inflector").

```{r}
# Pull out the first word in camel case (see http://stackoverflow.com/questions/29916065/how-to-do-camelcase-split-in-python)
camelCaseSplit <- function(s) str_split(s, '(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])')
```

```{r}
# Test the above
expect_equal(camelCaseSplit("RingPoleTipUpper")[[1]], c("Ring", "Pole", "Tip", "Upper"))
expect_equal(camelCaseSplit("ringPoleTipUpper")[[1]], c("ring", "Pole", "Tip", "Upper"))
expect_equal(camelCaseSplit("world")[[1]], c("world"))
expect_equal(camelCaseSplit("ringPole")[[1]], c("ring", "Pole"))
```

```{r}
# We really just want the first word
takeFirstCamel <- function(s) camelCaseSplit(s) %>% map_chr(function(s) s[1])
#
# Test
takeFirstCamel("RingPoleTipUpper") %>% expect_equal("Ring")
takeFirstCamel("ringPoleTipUpper") %>% expect_equal("ring")
takeFirstCamel("world") %>% expect_equal("world")
takeFirstCamel("ringPole") %>% expect_equal("ring")
takeFirstCamel(c("ringPoleTipUpper", "world")) %>% expect_equal(c("ring", "world"))
```

Don't confuse `RingTrackingPlane` with the iron (also starts with Ring)
```{r}
makeVolCategory <- function(s) ifelse( str_detect(s, 'RingTracking'),
                                       "RngTrkPlane",
                                       takeFirstCamel(s))
```
```{r}
makeVolCategory(c("RingBottom", "RingTrackingPlane[8]", "world")) %>% expect_equal(c("Ring", "RngTrkPlane", "world"))
```


```{r}
trackingActionNDF %>% mutate(volCategory = volName %>% makeVolCategory()) -> trackingActionNVDF
trackingActionNVDF %>% head(100)
```
Show count by category
```{r}
trackingActionNVDF %>% filter(trackID == 1) %>% group_by(scenario, volCategory) %>% tally() -> volCatTally
volCatTally %>% mutate(perc = n/20000 * 100) -> volCatTally
volCatTally
```
<a name="volCategoryPlots"/>Let's plot!
```{r}
trackingActionNVDF %>% filter(trackID ==1) %>% ggplot(aes(x=volCategory, group=scenario)) + 
  geom_bar()
```
```{r}
ggplot(volCatTally, aes(x = volCategory, y=perc, fill=scenario)) + 
  geom_bar(stat="Identity", width=0.5, position="dodge")
```
Can't really see non-Ring/world ones.  Let's split them out.

```{r}
# Function to make this easy
plotit <- function(d) ggplot(d, aes(x = volCategory, y=perc, fill=scenario) ) + 
  geom_bar(stat="Identity", width=0.5, position="dodge") + 
  xlab("Volume category") + ylab("Percent")

volCatTally %>% filter(volCategory %in% c("Ring", "world")) %>% plotit -> p1

volCatTally %>% filter(! volCategory %in% c("Ring", "world")) %>% plotit -> p2

grid.arrange(p1, p2)
```
Let's see where they die
```{r}
# See https://rpubs.com/hadley/97970 for how to wrap a multipart ggplot2 component
plotCommon <- function () {
  list(
    facet_wrap(~scenario),
    guides(col = guide_legend(override.aes = list(size=5, alpha=1))),
    scale_color_discrete(name="Volume\nCategory"),
    labs(x="z (mm)", y="x (mm)"),
    theme_minimal()
  )
}
```

<a name="coffeering"/>The "Coffee Ring" plots
```{r fig.height=8}
trackingActionNVDF %>% filter(trackID == 1) %>% 
  ggplot( aes(x=z, y=x, color=volCategory)) + 
    geom_point(alpha=0.1) + 
    ggtitle('Where Muons Die') +
    plotCommon()
```
Here it is without the ring losses, which dominate
```{r fig.height=8}
trackingActionNVDF %>% filter(trackID == 1, volCategory != 'Ring') %>% 
  ggplot( aes(x=z, y=x, color=volCategory)) + 
    geom_point(alpha=0.5) + 
    ggtitle("Where Muons Die", subtitle = "Ring escapees excluded for clarity") +
    plotCommon()
```

## Does it make sense for so many muons to stop in the iron?

We have 3 GeV muons. Does it make sense that the vast majority of them stop in the iron? A [table](http://pdg.lbl.gov/2016/AtomicNuclearProperties/MUE/muE_iron_Fe.pdf) shows the Continuous Slow Down Approximation range of muons (CSDA). For a 3 GeV muon in iron, the CSDA is $1.825 \times 10^{3}$ g/cm$^2$. The density $\rho$ is 7.874 g/cm$^3$. So, where $R$ is range, 

$$R = \text{CSDA}/\rho$$
Range is thus `r round(1825/7.874/100, 2)` m. This is bigger than the width of the iron, but remember that the muons come in at an oblique angle. We'll have to prove this. 

# How far do muons go in the iron?

We have the Geant stepping information, so we should be able to figure out how far the muons go in the iron. 

Here is the Gallery reader,
```{r}
read_file('GeantTrackReader.py') %>% cat
```
```{r}
geantStepReaderC <- createReaderClass_from_file('GeantTrackReader.py')$GeantStepReader
```

## Muon distance in iron for one event

Let's find an event where the muon did in the iron. 

```{r}
trackingActionNVDF %>% filter(trackID == 1, volName == 'RingYokeBottom') %>% head(100)
```
Event 4 looks good. 

```{r}
geantStepOne <- geantStepReaderC(artInputTag('artg4:KeepStepsAction'), tuple(as.integer(4)))
```
```{r}
getGalleryData(arrXrdFiles[1], geantStepOne)
```
```{r}
gsOneDF <- galleryReader_df(geantStepOne)
```

Merge in volume names
```{r}
gsOneDF %>% mutate(fileEntry = 1) %>%
  inner_join(volNameDF) %>% 
  select(volName, everything()) -> gsOneDF
gsOneDF
```
Let's make a 3D plot of this path

```{r}
ring <- cylinder3d( center=rbind(c(0,-90, 0), c(0,90,0)),
                    radius=7112,
                    sides=20, closed = F)
```

Let's do volume categories again.
```{r}
gsOneDF %>% mutate(volCategory = volName %>% makeVolCategory %>% as.factor) -> gsOneDF
```

<a name="muoniniron"/>Let's plot the path. Note that I have to make the legend separately since `legend3d` looks awful. 
```{r fig.width=5}
# lengend3d looks terrible - so do a regular legend
plot(1, type='n', axes=FALSE, ann=FALSE)
with(gsOneDF,
  legend("top", legend=unique(volCategory), col=as.integer(unique(volCategory)), pch=19)
)
```
```{r fig.width=8}
clear3d()
with(gsOneDF,{
     plot3d(x=x, y=y, z=z, type='p', col = as.integer(volCategory), ylim=c(-400, 400))
})
plot3d(ring, add=T, alpha=0.2)

view3d(phi=90, theta=-90)
rglwidget()
```
How much energy loss and distance traveled in each volume category
```{r}
gsOneDF %>% group_by(volCategory) %>% summarize(totalDist_meters=round(sum(stepLength)/1000, 2), 
                                                totalELoss_MeV=round(sum(totalEnergyDeposit), 1),
                                                nSteps = n())
```
Ok - I believe this (note that the y scale is very small compared to the x,z scales - so the muon acutally travels quite far in x & z). The muon travels about 2.4m in the iron and ranges out. Physics (and Geant) work!

Let's try another one
```{r}
geantStepOneA <- geantStepReaderC(artInputTag('artg4:KeepStepsAction'), tuple(as.integer(10)))
```

```{r}
getGalleryData(arrXrdFiles[1], geantStepOneA)
```

```{r}
gsOneADF <- galleryReader_df(geantStepOneA)
gsOneADF %>% mutate(fileEntry = 1) %>%
  inner_join(volNameDF) %>% 
  mutate(volCategory = volName %>% makeVolCategory %>% as.factor)%>% 
  select(volName, volCategory, everything()) -> gsOneADF
gsOneADF
```
```{r}
gsOneADF %>% group_by(volCategory) %>% summarize(totalDist_meters=round(sum(stepLength)/1000, 2), 
                                                totalELoss_MeV=round(sum(totalEnergyDeposit), 1),
                                                nSteps = n()) -> gsOneADFSum
gsOneADFSum
```
Check sums
```{r}
gsOneADFSum %>% summarize(sum(totalELoss_MeV))
```
```{r}
gsOneADF %>% summarize(sum(totalEnergyDeposit))
```
Sanity check passes!

<a name="muonScatInfl"/>
```{r}
# lengend3d looks terrible - so do a regular legend
plot(1, type='n', axes=FALSE, ann=FALSE)
with(gsOneADF,
  legend("top", legend=unique(volCategory), col=as.integer(unique(volCategory)), pch=19)
)
```

```{r}
clear3d()
with(gsOneADF,{
     plot3d(x=x, y=y, z=z, type='p', col = as.integer(volCategory), ylim=c(-400, 400), xlim=c(-10000, 10000),
            zlim=c(-10000, 10000))
})
plot3d(ring, add=T, alpha=0.2)

view3d(phi=90, theta=-90)
rglwidget()
```
This one scatters in the inflector. 

## Muon distance for many events

Can we show how far muons go in various materials?

Let's collect data for 100 events.

We have a reader that can do *n* events.
```{r}
read_file('GeantTrackReaderN.py') %>% cat
```
```{r}
geantStepReaderNC <- createReaderClass_from_file('GeantTrackReaderN.py')$GeantStepReaderN
```
```{r}
geantStepN <- geantStepReaderNC(artInputTag('artg4:KeepStepsAction'), 1000, 1000)
```

```{r}
getGalleryData(arrXrdFiles[1], geantStepN)
```
```{r}
gsNDF <- galleryReader_df(geantStepN)
gsNDF %>% mutate(fileEntry = 1,
                 p = sqrt(px*px + py*py + pz*pz)) %>%
  inner_join(volNameDF) %>% 
  mutate(volCategory = volName %>% makeVolCategory %>% as.factor)%>% 
  select(volName, volCategory, p, everything()) -> gsNDF
nrow(gsNDF)
gsNDF %>% head(100)
```
Let's do a distribution of distance in the different volumes
```{r}
gsNDF %>% group_by(eventEntry, volCategory) %>% summarize(
                                                totalDist_meters=round(sum(stepLength)/1000, 2), 
                                                totalELoss_MeV=round(sum(totalEnergyDeposit), 1),
                                                nSteps = n()) -> gsNDFSum
gsNDFSum
```
<a name="histdistring"/>
```{r}
gsNDFSum %>% filter(volCategory == 'Ring') %>% 
  ggplot(aes(x=totalDist_meters)) + geom_histogram(bins=50) + 
    labs(x = 'Total distance in Ring material (m)', y='count', title='Muon in Ring Material')
```
 Let's look at this across the volume categories for energy loss
 
 <a name="energyloss"/>
```{r}
gsNDFSum %>% ggplot(aes(x=totalELoss_MeV)) + geom_histogram(bins=50) +
  facet_wrap(~volCategory, scales = "free") + 
  labs(x = 'Total energy loss (MeV)', y='count', title='Energy loss in material',
       subtitle = 'Note the different scales')
```
Let's get an energy loss curve
```{r}
gsNDF %>% ggplot(aes(x=p, y=totalEnergyDeposit)) + geom_point() + facet_wrap(~volCategory) + 
  labs(x="Muon Momentum (MeV/c)", y="Total Energy loss (MeV))")
```
Well, not sure what all this means. Let's look for a particular event...
```{r}
gsNDF %>% filter(eventEntry == 1300) %>% ggplot(aes(x=p, y=totalEnergyDeposit)) + geom_point() + facet_wrap(~volCategory) + 
  labs(x="Muon Momentum (MeV/c)", y="Total Energy loss (MeV))", title='Energy loss vs. Momentum for muons in event 1300' )
```
<a name="nsteps"/>How many steps do we take?
```{r}
gsNDFSum %>% ggplot(aes(x=nSteps)) + geom_histogram(bins=50) +
  facet_wrap(~volCategory, scales = "free") + 
  labs(x = 'Number of steps', y='count', title='Number of steps in materials',
       subtitle = 'Note the different scales')
```

Let's look at two events

### Muon with long distance in iron

```{r}
gsNDFSum %>% filter(volCategory == 'Ring', totalDist_meters > 3)
```
Let's look at event 1758
```{r}
gsNDF %>% filter(eventEntry == 1758) -> gsNDF1758
gsNDF1758
```
```{r}
gsNDF1758 %>% group_by(eventEntry, volCategory) %>% summarize(
                                                totalDist_meters=round(sum(stepLength)/1000, 2), 
                                                totalELoss_MeV=round(sum(totalEnergyDeposit), 1),
                                                nSteps = n()) -> gsNDF1758Sum
gsNDF1758Sum
```
Let's plot it!

```{r}
gsNDF1758 %>% mutate(volCategory = as.factor(as.character(volCategory))) -> gsNDF1758
```

<a name="muonIronLong"/>
```{r}
# lengend3d looks terrible - so do a regular legend
plot(0, type='n', axes=FALSE, ann=FALSE)
with(gsNDF1758,
  legend("bottom", legend=unique(volCategory), col=as.integer(unique(volCategory)), pch=19)
)
```

```{r}
clear3d()
with(gsNDF1758,{
     plot3d(x=x, y=y, z=z, type='p', col = as.integer(volCategory), ylim=c(-400, 400), xlim=c(-10000, 10000),
            zlim=c(-10000, 10000))
})
plot3d(ring, add=T, alpha=0.2)
view3d(phi=90, theta=-90)
rglwidget()
```
Looks like this one started out in a strange place. 

### Muon with many turns

```{r}
gsNDFSum %>% filter(volCategory == 'Arc', totalDist_meters > 870)
```
Let's try event 1509

```{r}
gsNDF %>% filter(eventEntry == 1509) -> gsNDF1509
gsNDF1509
```
```{r}
gsNDF1509 %>% group_by(eventEntry, volCategory) %>% summarize(
                                                totalDist_meters=round(sum(stepLength)/1000, 2), 
                                                totalELoss_MeV=round(sum(totalEnergyDeposit), 1),
                                                nSteps = n()) -> gsNDF1509Sum
gsNDF1509Sum
```
Let's plot it!

```{r}
gsNDF1509 %>% mutate(volCategory = as.factor(as.character(volCategory))) -> gsNDF1509
```

<a name="longMuon"/>
```{r}
# lengend3d looks terrible - so do a regular legend
plot(0, type='n', axes=FALSE, ann=FALSE)
with(gsNDF1509,
  legend("bottom", legend=unique(volCategory), col=as.integer(unique(volCategory)), pch=19)
)
```

```{r}
clear3d()
with(gsNDF1509,{
     plot3d(x=x, y=y, z=z, type='p', col = as.integer(volCategory), ylim=c(-400, 400), xlim=c(-10000, 10000),
            zlim=c(-10000, 10000))
})
plot3d(ring, add=T, alpha=0.2)
view3d(phi=90, theta=-90)
rglwidget()
```
Looks like a nice stored muon!! Can we see CBO?

```{r}
gsNDF1509 %>% mutate(r = sqrt(x*x+z*z)) -> gsNDF1509
```

<a name="cbo"/>
```{r}
p1 <- gsNDF1509 %>% filter(volCategory %in% c('RngTrkPlane')) %>% ggplot(aes(x=globalTime, y=r)) + geom_line() +
  labs(x='Global time (ns)', y='Radius (mm)', title='Radial CBO', subtitle="Measured by Ring Tracking Planes")
#
p2 <- gsNDF1509 %>% filter(volCategory %in% c('Arc','RngTrkPlane')) %>% ggplot(aes(x=globalTime, y=r)) + 
  geom_line() + 
  labs(x='Global time (ns)', y='Radius (mm)', subtitle="Measured by Arc hits and Ring Tracking Planes")
#
grid.arrange(p1, p2)
```
We can even see the kick!

Here we'll plot the points too. 
```{r}
p1 <- gsNDF1509 %>% filter(volCategory %in% c('RngTrkPlane')) %>% ggplot(aes(x=globalTime, y=y)) + geom_line() +
  geom_point() +
  labs(x='Global time (ns)', y='y (mm)', title='Vertical CBO', subtitle="Measured by Ring Tracking Planes")
#
p2 <- gsNDF1509 %>% filter(volCategory %in% c('Arc','RngTrkPlane')) %>% ggplot(aes(x=globalTime, y=y)) + 
  geom_line() + geom_point() + 
  labs(x='Global time (ns)', y='y (mm)', subtitle="Measured by Arc hits and Ring Tracking Planes")
#
grid.arrange(p1, p2)
```
# "Ghost" cylinder at vacuum chamber

We want to examine muon escapees that leave the vacuum chamber. To measure this feature, we have a ghost cylinder at the outer wall of the vacuum chamber as well as above and below the storage region (before the muon would hit iron). That should catch every muon that doesn't get stored and makes it out of the storage region. The data is `gm2truth::GhostDetectorArtRecords_artg4_GhostCylinderDetector`.

There is also a ghost cylinder just on the inside of the world cube to see muons that would actually leave the ring (and make it through the iron). The data is `gm2truth::GhostDetectorArtRecords_artg4_GhostNearWorldDetector`. 

## Load the Ghost cylinder data

See [gm2dataproducts/mc/ghostdetectors/GhostDetectorArtRecord.hh](https://cdcvs.fnal.gov/redmine/projects/gm2dataproducts/repository/entry/mc/ghostdetectors/GhostDetectorArtRecord.hh?rev=feature%2Fmdc2) .

```r
readerClassSkel('gm2truth::GhostDetectorArtRecord', writeFile = 'GhostDetectorReader.py')
```
```{r}
read_file('GhostDetectorReader.py') %>% cat
```


```{r}
ghostDetectorReaderC <- createReaderClass_from_file('GhostDetectorReader.py')$GhostDetectorArtRecordReader
```

Let's read both ghost cylinders
```{r}
ghCylReader <- ghostDetectorReaderC(artInputTag('artg4:GhostCylinderDetector'))
ghWldReader <- ghostDetectorReaderC(artInputTag('artg4:GhostNearWorldDetector'))
```

Load for one file
```{r}
getGalleryData(arrXrdFiles, c(ghCylReader, ghWldReader))
```
Load the data into R

```{r}
ghCylDF <- galleryReader_df(ghCylReader)
ghWldDF <- galleryReader_df(ghWldReader)
```

Look at what we got
```{r}
nrow(ghCylDF) %>% format(big.mark=",")
nrow(ghWldDF) %>% format(big.mark=",")
```

```{r}
ghCylDF %>% head(100)
```
```{r}
ghWldDF %>% head(100)
```
```{r}
write_rds(ghCylDF, 'ghCylDF.rds')  # Write out just in case, since these are expensive to extract
write_rds(ghWldDF, 'ghWldDF.rds')
```

Fill in the scenario and pdg
```{r}
pdgs <- c('e-'= 11, 'nu_e'= 12, 'mu-'= 13, 'nu_mu'= 14, 'tau-'= 15, 'nu_tau'= 16,
          'e+'=-11, 'anti_nu_e'=-12, 'mu+'=-13, 'anti_nu_mu'=-14, 'tau+'=-15, 'anti_nu_tau'=-16,
          'gam'=22, 'p'=2212, 'n'=2112, 'anti-p'=-2212, 'anti-n'=-2112)
pdgs
```

```{r}
# We need to be a little careful, since the scenario names are repeated (we have two files per scenario). 
# We can't make factor levels out of that. 
# The file entries with 0-5 are easy. 6-11 are harder
addScenarioFactor <- function(f) factor(if_else(f >= 6, as.integer(f-6), f), 
                                        levels=0:(length(unique(scenarios))-1), labels=unique(scenarios))
#
mutateThis <- function(df) mutate(df, 
                       scenario = addScenarioFactor(fileEntry),
                            pdg = factor(particleID, levels=pdgs, labels=names(pdgs)),
                              r = sqrt(x*x+z*z),
                            phi = atan2(z, x) %>% if_else(. > 0, ., 2*pi+ .) * (360.0/(2*pi)) )
#
ghCylDF %>% mutateThis -> ghCylDF
#
ghWldDF %>% mutateThis -> ghWldDF
```

## Vacuum chamber ghost cylinder

Pull out just the muon
```{r}
ghCylDF %>% filter(trackID == 1) -> ghCylMuDF
nrow(ghCylMuDF) %>% format(big.mark=',')
```
Let's practice with just the *everything* scenario
```{r}
ghCylMu_everything_DF <- ghCylMuDF %>% filter(scenario == 'everything')
nrow(ghCylMu_everything_DF) %>% format(big.mark=',')
```
Let's plot where these are

```{r}
clear3d()
with(ghCylMu_everything_DF,
     plot3d(x=x, y=y, z=z, main='Everything'))
plot3d(ring, add=T, alpha=0.2)
view3d(phi=90, theta=-90)
rglwidget()
```
They're all lost up or down, not along the side. Let's try more of the scenarios.
```{r}
clear3d()
with(ghCylMuDF %>% filter(scenario == scenarios[2]),
     plot3d(x=x, y=y, z=z, xlim=c(-6000, 6000), ylim=c(-110, 110), zlim=c(-6000, 6000), main=scenarios[2]))
plot3d(ring, add=T, alpha=0.2)
view3d(phi=90, theta=-90)
rglwidget()
```
OK - this isn't terribly useful. What would be better is to 

